// File lang/cpp/src/parseUbxMessage.cpp
// Auto-generated by pyUBX generateCPP.py v0.1 on 2023-04-08T18:19:00.008387
// See https://github.com/mayeranalytics/pyUBX
// DO NOT MODIFY THIS FILE!
#include <cstring>
#include "parseUbxMessage.hpp"

using namespace std;
using namespace ubx;

std::shared_ptr<SerializeCommon> ParseUbxMessage::createUbx(const uint8_t *buf, uint16_t len, uint8_t classId, uint8_t messageID, bool isGet) const
{
    shared_ptr<SerializeCommon> ret = nullptr;

    switch(classId)
    {
        case ::ACK::classID: // Message class ACK
        {
            switch(messageID)
            {
                case ACK::ACK::messageID: // Message ACK-ACK
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<ACK::ACK>(new (heap) ACK::ACK);
                    break;
                }
                case ACK::NAK::messageID: // Message ACK-NAK
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<ACK::NAK>(new (heap) ACK::NAK);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::CFG::classID: // Message class CFG
        {
            switch(messageID)
            {
                case CFG::CFG::messageID: // Message CFG-CFG
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<CFG::CFG>(new (heap) CFG::CFG);
                    break;
                }
                case CFG::GNSS::messageID: // Message CFG-GNSS
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len + 2U];
                    ret = shared_ptr<CFG::GNSS>(new (heap) CFG::GNSS);
                    dynamic_cast<CFG::GNSS*>(ret.get())->repeatedLen = (len - sizeof(struct CFG::GNSS::_data)) / sizeof(struct CFG::GNSS::_data::_repeated);
                    break;
                }
                case CFG::INF::messageID: // Message CFG-INF
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len + 2U];
                    ret = shared_ptr<CFG::INF>(new (heap) CFG::INF);
                    dynamic_cast<CFG::INF*>(ret.get())->repeatedLen = (len - sizeof(struct CFG::INF::_data)) / sizeof(struct CFG::INF::_data::_repeated);
                    break;
                }
                case CFG::LOGFILTER::messageID: // Message CFG-LOGFILTER
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<CFG::LOGFILTER>(new (heap) CFG::LOGFILTER);
                    break;
                }
                case CFG::MSG::messageID: // Message CFG-MSG
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<CFG::MSG>(new (heap) CFG::MSG);
                    break;
                }
                case CFG::NAVX5::messageID: // Message CFG-NAVX5
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<CFG::NAVX5>(new (heap) CFG::NAVX5);
                    break;
                }
                case CFG::PM2::messageID: // Message CFG-PM2
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<CFG::PM2>(new (heap) CFG::PM2);
                    break;
                }
                case CFG::PMS::messageID: // Message CFG-PMS
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<CFG::PMS>(new (heap) CFG::PMS);
                    break;
                }
                case CFG::PRT::messageID: // Message CFG-PRT
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<CFG::PRT_GET>(new (heap) CFG::PRT_GET);
                    }
                    else
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<CFG::PRT>(new (heap) CFG::PRT);
                    }
                    break;
                }
                case CFG::RATE::messageID: // Message CFG-RATE
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<CFG::RATE>(new (heap) CFG::RATE);
                    break;
                }
                case CFG::RXM::messageID: // Message CFG-RXM
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<CFG::RXM>(new (heap) CFG::RXM);
                    break;
                }
                case CFG::TP5::messageID: // Message CFG-TP5
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<CFG::TP5_GET>(new (heap) CFG::TP5_GET);
                    }
                    else
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<CFG::TP5>(new (heap) CFG::TP5);
                    }
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::ESF::classID: // Message class ESF
        {
            switch(messageID)
            {
                case ESF::MEAS::messageID: // Message ESF-MEAS
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len + 2U];
                    ret = shared_ptr<ESF::MEAS>(new (heap) ESF::MEAS);
                    dynamic_cast<ESF::MEAS*>(ret.get())->repeatedLen = (len - sizeof(struct ESF::MEAS::_data)) / sizeof(struct ESF::MEAS::_data::_repeated);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::LOG::classID: // Message class LOG
        {
            switch(messageID)
            {
                case LOG::CREATE::messageID: // Message LOG-CREATE
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<LOG::CREATE>(new (heap) LOG::CREATE);
                    break;
                }
                case LOG::ERASE::messageID: // Message LOG-ERASE
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<LOG::ERASE>(new (heap) LOG::ERASE);
                    break;
                }
                case LOG::FINDTIME::messageID: // Message LOG-FINDTIME
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<LOG::FINDTIME_GET>(new (heap) LOG::FINDTIME_GET);
                    }
                    else
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<LOG::FINDTIME>(new (heap) LOG::FINDTIME);
                    }
                    break;
                }
                case LOG::INFO::messageID: // Message LOG-INFO
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<LOG::INFO_GET>(new (heap) LOG::INFO_GET);
                    }
                    else
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<LOG::INFO>(new (heap) LOG::INFO);
                    }
                    break;
                }
                case LOG::RETRIEVE::messageID: // Message LOG-RETRIEVE
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<LOG::RETRIEVE>(new (heap) LOG::RETRIEVE);
                    break;
                }
                case LOG::RETRIEVEPOS::messageID: // Message LOG-RETRIEVEPOS
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<LOG::RETRIEVEPOS>(new (heap) LOG::RETRIEVEPOS);
                    break;
                }
                case LOG::RETRIEVEPOSEXTRA::messageID: // Message LOG-RETRIEVEPOSEXTRA
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<LOG::RETRIEVEPOSEXTRA>(new (heap) LOG::RETRIEVEPOSEXTRA);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::MGA::classID: // Message class MGA
        {
            switch(messageID)
            {
                case MGA::ACK_DATA0::messageID: // Message MGA-ACK_DATA0
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<MGA::ACK_DATA0>(new (heap) MGA::ACK_DATA0);
                    break;
                }
                case MGA::FLASH_ACK::messageID: // Message MGA-FLASH_ACK
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<MGA::FLASH_ACK>(new (heap) MGA::FLASH_ACK);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::MON::classID: // Message class MON
        {
            switch(messageID)
            {
                case MON::HW::messageID: // Message MON-HW
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<MON::HW>(new (heap) MON::HW);
                    break;
                }
                case MON::SPAN::messageID: // Message MON-SPAN
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len + 2U];
                    ret = shared_ptr<MON::SPAN>(new (heap) MON::SPAN);
                    dynamic_cast<MON::SPAN*>(ret.get())->repeatedLen = (len - sizeof(struct MON::SPAN::_data)) / sizeof(struct MON::SPAN::_data::_repeated);
                    break;
                }
                case MON::VER::messageID: // Message MON-VER
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len + 2U];
                        ret = shared_ptr<MON::VER_GET>(new (heap) MON::VER_GET);
                        dynamic_cast<MON::VER_GET*>(ret.get())->repeatedLen = (len - sizeof(struct MON::VER_GET::_data)) / sizeof(struct MON::VER_GET::_data::_repeated);
                    }
                    else
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<MON::VER>(new (heap) MON::VER);
                    }
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::NAV::classID: // Message class NAV
        {
            switch(messageID)
            {
                case NAV::DOP::messageID: // Message NAV-DOP
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<NAV::DOP>(new (heap) NAV::DOP);
                    break;
                }
                case NAV::PVT::messageID: // Message NAV-PVT
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<NAV::PVT_GET>(new (heap) NAV::PVT_GET);
                    }
                    else
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<NAV::PVT>(new (heap) NAV::PVT);
                    }
                    break;
                }
                case NAV::RELPOSNED::messageID: // Message NAV-RELPOSNED
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<NAV::RELPOSNED>(new (heap) NAV::RELPOSNED);
                    break;
                }
                case NAV::SAT::messageID: // Message NAV-SAT
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len + 2U];
                        ret = shared_ptr<NAV::SAT_GET>(new (heap) NAV::SAT_GET);
                        dynamic_cast<NAV::SAT_GET*>(ret.get())->repeatedLen = (len - sizeof(struct NAV::SAT_GET::_data)) / sizeof(struct NAV::SAT_GET::_data::_repeated);
                    }
                    else
                    {
                        uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                        ret = shared_ptr<NAV::SAT>(new (heap) NAV::SAT);
                    }
                    break;
                }
                case NAV::SVINFO::messageID: // Message NAV-SVINFO
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len + 2U];
                    ret = shared_ptr<NAV::SVINFO>(new (heap) NAV::SVINFO);
                    dynamic_cast<NAV::SVINFO*>(ret.get())->repeatedLen = (len - sizeof(struct NAV::SVINFO::_data)) / sizeof(struct NAV::SVINFO::_data::_repeated);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::TEST::classID: // Message class TEST
        {
            switch(messageID)
            {
                case TEST::TEST::messageID: // Message TEST-TEST
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len + 2U];
                    ret = shared_ptr<TEST::TEST>(new (heap) TEST::TEST);
                    dynamic_cast<TEST::TEST*>(ret.get())->repeatedLen = (len - sizeof(struct TEST::TEST::_data)) / sizeof(struct TEST::TEST::_data::_repeated);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::TIM::classID: // Message class TIM
        {
            switch(messageID)
            {
                case TIM::SVIN::messageID: // Message TIM-SVIN
                {
                    uint8_t *heap = new uint8_t[sizeof(ubx::SerializeCommon) + len];
                    ret = shared_ptr<TIM::SVIN>(new (heap) TIM::SVIN);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        default:
        {
            break;
        }
    }
    if (ret != nullptr)
    {
        (void)memcpy(ret->getDataStartAddress(), buf, len);
    }

    return ret;
}
