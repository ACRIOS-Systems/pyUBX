// File lang/cpp/src/parseUbxMessage.cpp
// Auto-generated by pyUBX generateCPP.py v0.2 on 2023-06-06T19:57:04.624976
// See https://github.com/mayeranalytics/pyUBX
// DO NOT MODIFY THIS FILE!
#include <cstring>
#include "parseUbxMessage.hpp"

using namespace std;
using namespace ubx;

std::shared_ptr<SerializeCommon> ParseUbxMessage::createUbx(const uint8_t *buf, uint16_t len, uint8_t classId, uint8_t messageID, bool isGet) const
{
    shared_ptr<SerializeCommon> ret = nullptr;

    switch(classId)
    {
        case ::ACK::classID: // Message class ACK
        {
            switch(messageID)
            {
                case ACK::ACK::messageID: // Message ACK-ACK
                {
                    ret = shared_ptr<ACK::ACK>(new ACK::ACK);
                    break;
                }
                case ACK::NAK::messageID: // Message ACK-NAK
                {
                    ret = shared_ptr<ACK::NAK>(new ACK::NAK);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::CFG::classID: // Message class CFG
        {
            switch(messageID)
            {
                case CFG::CFG::messageID: // Message CFG-CFG
                {
                    ret = shared_ptr<CFG::CFG>(new CFG::CFG);
                    break;
                }
                case CFG::GNSS::messageID: // Message CFG-GNSS
                {
                    uint8_t *heap = new uint8_t[sizeof(CFG::GNSS) + (len - sizeof(struct CFG::GNSS::_data))];
                    ret = shared_ptr<CFG::GNSS>(new (heap) CFG::GNSS);
                    dynamic_cast<CFG::GNSS*>(ret.get())->repeatedLen = (len - sizeof(struct CFG::GNSS::_data)) / sizeof(struct CFG::GNSS::_data::_repeated);
                    break;
                }
                case CFG::INF::messageID: // Message CFG-INF
                {
                    uint8_t *heap = new uint8_t[sizeof(CFG::INF) + (len - sizeof(struct CFG::INF::_data))];
                    ret = shared_ptr<CFG::INF>(new (heap) CFG::INF);
                    dynamic_cast<CFG::INF*>(ret.get())->repeatedLen = (len - sizeof(struct CFG::INF::_data)) / sizeof(struct CFG::INF::_data::_repeated);
                    break;
                }
                case CFG::LOGFILTER::messageID: // Message CFG-LOGFILTER
                {
                    ret = shared_ptr<CFG::LOGFILTER>(new CFG::LOGFILTER);
                    break;
                }
                case CFG::MSG::messageID: // Message CFG-MSG
                {
                    ret = shared_ptr<CFG::MSG>(new CFG::MSG);
                    break;
                }
                case CFG::NAVX5::messageID: // Message CFG-NAVX5
                {
                    ret = shared_ptr<CFG::NAVX5>(new CFG::NAVX5);
                    break;
                }
                case CFG::PM2::messageID: // Message CFG-PM2
                {
                    ret = shared_ptr<CFG::PM2>(new CFG::PM2);
                    break;
                }
                case CFG::PMS::messageID: // Message CFG-PMS
                {
                    ret = shared_ptr<CFG::PMS>(new CFG::PMS);
                    break;
                }
                case CFG::PRT::messageID: // Message CFG-PRT
                {
                    if (isGet)
                    {
                        ret = shared_ptr<CFG::PRT_GET>(new CFG::PRT_GET);
                    }
                    else
                    {
                        ret = shared_ptr<CFG::PRT>(new CFG::PRT);
                    }
                    break;
                }
                case CFG::RATE::messageID: // Message CFG-RATE
                {
                    ret = shared_ptr<CFG::RATE>(new CFG::RATE);
                    break;
                }
                case CFG::RXM::messageID: // Message CFG-RXM
                {
                    ret = shared_ptr<CFG::RXM>(new CFG::RXM);
                    break;
                }
                case CFG::TP5::messageID: // Message CFG-TP5
                {
                    if (isGet)
                    {
                        ret = shared_ptr<CFG::TP5_GET>(new CFG::TP5_GET);
                    }
                    else
                    {
                        ret = shared_ptr<CFG::TP5>(new CFG::TP5);
                    }
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::ESF::classID: // Message class ESF
        {
            switch(messageID)
            {
                case ESF::MEAS::messageID: // Message ESF-MEAS
                {
                    uint8_t *heap = new uint8_t[sizeof(ESF::MEAS) + (len - sizeof(struct ESF::MEAS::_data))];
                    ret = shared_ptr<ESF::MEAS>(new (heap) ESF::MEAS);
                    dynamic_cast<ESF::MEAS*>(ret.get())->repeatedLen = (len - sizeof(struct ESF::MEAS::_data)) / sizeof(struct ESF::MEAS::_data::_repeated);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::LOG::classID: // Message class LOG
        {
            switch(messageID)
            {
                case LOG::CREATE::messageID: // Message LOG-CREATE
                {
                    ret = shared_ptr<LOG::CREATE>(new LOG::CREATE);
                    break;
                }
                case LOG::ERASE::messageID: // Message LOG-ERASE
                {
                    ret = shared_ptr<LOG::ERASE>(new LOG::ERASE);
                    break;
                }
                case LOG::FINDTIME::messageID: // Message LOG-FINDTIME
                {
                    if (isGet)
                    {
                        ret = shared_ptr<LOG::FINDTIME_GET>(new LOG::FINDTIME_GET);
                    }
                    else
                    {
                        ret = shared_ptr<LOG::FINDTIME>(new LOG::FINDTIME);
                    }
                    break;
                }
                case LOG::INFO::messageID: // Message LOG-INFO
                {
                    if (isGet)
                    {
                        ret = shared_ptr<LOG::INFO_GET>(new LOG::INFO_GET);
                    }
                    else
                    {
                        ret = shared_ptr<LOG::INFO>(new LOG::INFO);
                    }
                    break;
                }
                case LOG::RETRIEVE::messageID: // Message LOG-RETRIEVE
                {
                    ret = shared_ptr<LOG::RETRIEVE>(new LOG::RETRIEVE);
                    break;
                }
                case LOG::RETRIEVEPOS::messageID: // Message LOG-RETRIEVEPOS
                {
                    ret = shared_ptr<LOG::RETRIEVEPOS>(new LOG::RETRIEVEPOS);
                    break;
                }
                case LOG::RETRIEVEPOSEXTRA::messageID: // Message LOG-RETRIEVEPOSEXTRA
                {
                    ret = shared_ptr<LOG::RETRIEVEPOSEXTRA>(new LOG::RETRIEVEPOSEXTRA);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::MGA::classID: // Message class MGA
        {
            switch(messageID)
            {
                case MGA::ACK_DATA0::messageID: // Message MGA-ACK_DATA0
                {
                    ret = shared_ptr<MGA::ACK_DATA0>(new MGA::ACK_DATA0);
                    break;
                }
                case MGA::FLASH_ACK::messageID: // Message MGA-FLASH_ACK
                {
                    ret = shared_ptr<MGA::FLASH_ACK>(new MGA::FLASH_ACK);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::MON::classID: // Message class MON
        {
            switch(messageID)
            {
                case MON::HW::messageID: // Message MON-HW
                {
                    ret = shared_ptr<MON::HW>(new MON::HW);
                    break;
                }
                case MON::SPAN::messageID: // Message MON-SPAN
                {
                    uint8_t *heap = new uint8_t[sizeof(MON::SPAN) + (len - sizeof(struct MON::SPAN::_data))];
                    ret = shared_ptr<MON::SPAN>(new (heap) MON::SPAN);
                    dynamic_cast<MON::SPAN*>(ret.get())->repeatedLen = (len - sizeof(struct MON::SPAN::_data)) / sizeof(struct MON::SPAN::_data::_repeated);
                    break;
                }
                case MON::VER::messageID: // Message MON-VER
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(MON::VER_GET) + (len - sizeof(struct MON::VER_GET::_data))];
                        ret = shared_ptr<MON::VER_GET>(new (heap) MON::VER_GET);
                        dynamic_cast<MON::VER_GET*>(ret.get())->repeatedLen = (len - sizeof(struct MON::VER_GET::_data)) / sizeof(struct MON::VER_GET::_data::_repeated);
                    }
                    else
                    {
                        ret = shared_ptr<MON::VER>(new MON::VER);
                    }
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::NAV::classID: // Message class NAV
        {
            switch(messageID)
            {
                case NAV::DOP::messageID: // Message NAV-DOP
                {
                    ret = shared_ptr<NAV::DOP>(new NAV::DOP);
                    break;
                }
                case NAV::PVT::messageID: // Message NAV-PVT
                {
                    if (isGet)
                    {
                        ret = shared_ptr<NAV::PVT_GET>(new NAV::PVT_GET);
                    }
                    else
                    {
                        ret = shared_ptr<NAV::PVT>(new NAV::PVT);
                    }
                    break;
                }
                case NAV::RELPOSNED::messageID: // Message NAV-RELPOSNED
                {
                    ret = shared_ptr<NAV::RELPOSNED>(new NAV::RELPOSNED);
                    break;
                }
                case NAV::SAT::messageID: // Message NAV-SAT
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(NAV::SAT_GET) + (len - sizeof(struct NAV::SAT_GET::_data))];
                        ret = shared_ptr<NAV::SAT_GET>(new (heap) NAV::SAT_GET);
                        dynamic_cast<NAV::SAT_GET*>(ret.get())->repeatedLen = (len - sizeof(struct NAV::SAT_GET::_data)) / sizeof(struct NAV::SAT_GET::_data::_repeated);
                    }
                    else
                    {
                        ret = shared_ptr<NAV::SAT>(new NAV::SAT);
                    }
                    break;
                }
                case NAV::SVINFO::messageID: // Message NAV-SVINFO
                {
                    uint8_t *heap = new uint8_t[sizeof(NAV::SVINFO) + (len - sizeof(struct NAV::SVINFO::_data))];
                    ret = shared_ptr<NAV::SVINFO>(new (heap) NAV::SVINFO);
                    dynamic_cast<NAV::SVINFO*>(ret.get())->repeatedLen = (len - sizeof(struct NAV::SVINFO::_data)) / sizeof(struct NAV::SVINFO::_data::_repeated);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::RXM::classID: // Message class RXM
        {
            switch(messageID)
            {
                case RXM::IMES::messageID: // Message RXM-IMES
                {
                    if (isGet)
                    {
                        uint8_t *heap = new uint8_t[sizeof(RXM::IMES_GET) + (len - sizeof(struct RXM::IMES_GET::_data))];
                        ret = shared_ptr<RXM::IMES_GET>(new (heap) RXM::IMES_GET);
                        dynamic_cast<RXM::IMES_GET*>(ret.get())->repeatedLen = (len - sizeof(struct RXM::IMES_GET::_data)) / sizeof(struct RXM::IMES_GET::_data::_repeated);
                    }
                    else
                    {
                        ret = shared_ptr<RXM::IMES>(new RXM::IMES);
                    }
                    break;
                }
                case RXM::MEASX::messageID: // Message RXM-MEASX
                {
                    ret = shared_ptr<RXM::MEASX>(new RXM::MEASX);
                    break;
                }
                case RXM::PMREQ::messageID: // Message RXM-PMREQ
                {
                    ret = shared_ptr<RXM::PMREQ>(new RXM::PMREQ);
                    break;
                }
                case RXM::PMREQ2::messageID: // Message RXM-PMREQ2
                {
                    ret = shared_ptr<RXM::PMREQ2>(new RXM::PMREQ2);
                    break;
                }
                case RXM::RAWX::messageID: // Message RXM-RAWX
                {
                    ret = shared_ptr<RXM::RAWX>(new RXM::RAWX);
                    break;
                }
                case RXM::RLM::messageID: // Message RXM-RLM
                {
                    ret = shared_ptr<RXM::RLM>(new RXM::RLM);
                    break;
                }
                case RXM::RTCM::messageID: // Message RXM-RTCM
                {
                    ret = shared_ptr<RXM::RTCM>(new RXM::RTCM);
                    break;
                }
                case RXM::SFRBX::messageID: // Message RXM-SFRBX
                {
                    ret = shared_ptr<RXM::SFRBX>(new RXM::SFRBX);
                    break;
                }
                case RXM::SVSI::messageID: // Message RXM-SVSI
                {
                    ret = shared_ptr<RXM::SVSI>(new RXM::SVSI);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::TEST::classID: // Message class TEST
        {
            switch(messageID)
            {
                case TEST::TEST::messageID: // Message TEST-TEST
                {
                    uint8_t *heap = new uint8_t[sizeof(TEST::TEST) + (len - sizeof(struct TEST::TEST::_data))];
                    ret = shared_ptr<TEST::TEST>(new (heap) TEST::TEST);
                    dynamic_cast<TEST::TEST*>(ret.get())->repeatedLen = (len - sizeof(struct TEST::TEST::_data)) / sizeof(struct TEST::TEST::_data::_repeated);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        case ::TIM::classID: // Message class TIM
        {
            switch(messageID)
            {
                case TIM::SVIN::messageID: // Message TIM-SVIN
                {
                    ret = shared_ptr<TIM::SVIN>(new TIM::SVIN);
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
        default:
        {
            break;
        }
    }
    if (ret != nullptr)
    {
        (void)memcpy(ret->getDataStartAddress(), buf, ret->getDataSize());
    }

    return ret;
}
