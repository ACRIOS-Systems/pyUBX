# `pyUBX/lang/cpp`

This is the C++ source code, partially generated by `<root>/ubx/generateCpp.py `.

## Overview

PyUBX is a small but functional Python3 wrapper for the u-blox M8 UBX protocol (see [UBX-13003221 - R13, ยง31](https://www.u-blox.com/sites/default/files/products/documents/u-blox8-M8_ReceiverDescrProtSpec_(UBX-13003221)_Public.pdf)).

The key features are:

- parse, generate and manipulate UBX messages
- message definitions are simple, uncluttered Python code (class definitions)
- decorators keep the boilerplate code at a minimum
- interact with a device using a REPL
- use as a parser generator for other languages or definition files for other parser generators, implemented are:
  - [C++](lang/cpp/readme.md)

## C++

The pyUBX python classes in folder `<root>/ubx/UBX/` are translated into C++ classes by `generateCpp.py`. They can be found in `<root>/lang/cpp/src`.

### Message structs

Every struct inherit functions from common class SerializeCommon. This object contains generic virtual functions which every ubx object implements.

It is easiest to look at an example. Below we see declaration for request and response structures of MON-VER type. Description of virtual functions can be found in declaration of SerializeCommon class. `Data` structure contains ubx payload data for type. Inside that structure can be placed `repeated` structure which represent array of data.

```CPP
#ifndef __MON_H__
#define __MON_H__
#include "Ubx.hpp"

/* Message class MON.
 */
namespace ubx
{

namespace MON
{
    struct __attribute__((packed)) VER : public SerializeCommon
    {
        virtual uint8_t getClassId(void) const override;
        virtual uint8_t getMessageId(void) const override;
        virtual const std::string &getClassName(void) const override;
        virtual std::string getMessageName(void) const override;
        virtual std::string getDescription(void) const override;
        virtual uint8_t* getDataStartAddress(void) const override;
        virtual uint16_t getDataSize(void) const override;

        static constexpr uint8_t messageID = 4;

        struct __attribute__((packed)) _data {

        } data;
    };

    struct __attribute__((packed)) VER_GET : public SerializeCommon
    {
        uint16_t repeatedLen; /* Set N-count array dimension of repeated structure. Do not serialize this byte*/
        static const uint16_t repeatedSize;
        virtual uint8_t getClassId(void) const override;
        virtual uint8_t getMessageId(void) const override;
        virtual const std::string &getClassName(void) const override;
        virtual std::string getMessageName(void) const override;
        virtual std::string getDescription(void) const override;
        virtual uint8_t* getDataStartAddress(void) const override;
        virtual uint16_t getDataSize(void) const override;

        static constexpr uint8_t messageID = 4;

        struct __attribute__((packed)) _data {
            char swVersion[30];
            char hwVersion[10];

            struct __attribute__((packed)) _repeated {
                char extension[30];
            } repeated [0]; /* [0] -> to pass compilation. Length is set by repeatedLen. Do not forget alloc enough space*/

        } data;
    };
};
};
```

Below is example to create variable without repeated structure

```CPP
ubx::MON::VER ver;
```

Below is example to create variable on stack with repeated structure

```CPP
int repeatedCount = 5;
char verPayload[sizeof(ubx::MON::VER_GET) + repeatedCount * sizeof(struct ubx::MON::VER_GET::_data::__repeated)];
ubx::MON::VER_GET *ver = new (verPayload) ubx::MON::VER_GET;
ver->repeatedLen = repeatedCount;
```

### Class Structure

Both NMEA and UBX messages have a layered structure, i.e. the payload is wrapped inside a control structure that includes a checksum and, for UBX, message identification and length. The C++ classes follow this nested structure.

#### UBX Parsing

Class `ParseUbxMessage` contains two parseUbx function. One is parsing data from buffer which contains ubx control bytes (ubx header, payload size, ...), second is parsing data from buffer which contains only ubx object type data. In second case message id and class id are past to function as parameters.
Return value is nullptr or shared_ptr\<SerializeCommon\>. The shared_ptr allow us to allocate sufficient enough memory and memory is freed once no variable is holding this shared_ptr. SerializeCommon class can be retyped to expected structure which can be identified using `getClassId` and `getMessageId` functions.

```CPP
ACK::ACK ack1; /* different scope as _ubx */
{
    shared_ptr<SerializeCommon> _ubx = ParseUbxMessage().parse(buf,len);
    ACK::ACK *ack2; /* same scope as _ubx */
    if (_ubx != nullptr)
    {
        if (_ubx.getClassId() == 5)
        {
            if (_ubx.getMessageId() == 1)
            {
                memcpy(ack1.getDataStartAddress(), _ubx->getDataStartAddress(), _ubx->getDataSize());

                ack2 = dynamic_cast<ACK::ACK*>(_ubx.get());
            }
        }
    }
}
```

## Serialization

As every message type is inhering SerializeCommon class, every message type can use two types of serialization function. One function accept buffer and length into which are data serialized (buffer length need be at least payload data size + ubx control data size). Second function accept callback function reference and callback user data.

```CPP
ubx::MON::VER ver;
char buffer[sizeof(struct ubx::MON::VER::_data) + SerializeCommon::UbxControlBytesSize]; // ver.getDataSize() + SerializeCommon::UbxControlBytesSize
int bufferLength = sizeof(struct ubx::MON::VER::_data) + SerializeCommon::UbxControlBytesSize;
ver.serialize(buffer, bufferLength);
```

## Testing

Currently no public available tests.
